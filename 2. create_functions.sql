--------------------------------------------------------------------------------------------------
-- data.logs

CREATE OR REPLACE FUNCTION data.logs()
RETURNS SETOF text AS
$BODY$

BEGIN

    INSERT INTO aliases.string_id (string_id) -- alias_id will be autogenerated
    SELECT a.string_id
    FROM (
      SELECT trim(TRAILING '.log' FROM trim(node)) AS string_id FROM tmp.node_a_alarm GROUP BY 1 UNION
      SELECT trim(TRAILING '.log' FROM trim(node)) AS string_id FROM tmp.node_a_event GROUP BY 1 UNION
      SELECT trim(TRAILING '.log' FROM trim(node)) AS string_id FROM tmp.node_a_restart GROUP BY 1 UNION
      SELECT trim(TRAILING '.log' FROM trim(node)) AS string_id FROM tmp.node_b_alarm GROUP BY 1 UNION
      SELECT trim(TRAILING '.log' FROM trim(node)) AS string_id FROM tmp.node_b_event GROUP BY 1
    ) AS a
    LEFT JOIN aliases.string_id AS b
    ON a.string_id = b.string_id
    WHERE b.string_id IS NULL
    GROUP BY a.string_id;
    
    TRUNCATE data.logs;
    
    INSERT INTO data.logs (
      alias_id, 
      node_type, 
      timestamp, 
      log_type, 
      flag, 
      record)
    SELECT
      b.alias_id,
      'a' AS node_type,
      (a.date_part||' '||a.time_part)::timestamp at time zone 'UTC' at time zone 'HKT' AS timestamp,
      trim(a.type) AS log_type,
      trim(a.flag) AS flag,
      trim(a.record) AS record
    FROM tmp.node_a_alarm AS a
    INNER JOIN aliases.string_id AS b
    ON trim(TRAILING '.log' FROM trim(a.node)) = b.string_id;
    
    INSERT INTO data.logs (
      alias_id, 
      node_type, 
      timestamp, 
      log_type, 
      flag, 
      record)
    SELECT
      b.alias_id,
      'a' AS node_type,
      (a.date_part||' '||a.time_part)::timestamp at time zone 'UTC' at time zone 'HKT' AS timestamp,
      trim(a.type) AS log_type,
      trim(a.flag) AS flag,
      trim(a.record) AS record
    FROM (
      SELECT *
      FROM tmp.node_a_restart
      WHERE to_number(substring(time_part,1,3),'99') not in (16,17,18,19,20,21) -- Ignore maintenance restarts from 0:00 to 06:00 HKT
      EXCEPT
      SELECT a.*
      FROM tmp.node_a_restart a
      INNER JOIN tmp.rnc_maintenance b
      ON trim(TRAILING '.log' FROM trim(a.node)) = b.rnc
      WHERE (a.date_part||' '||a.time_part)::timestamp at time zone 'UTC' at time zone 'HKT' like b.maintenance_timestamp||'%'
      OR    (b.maintenance_type = 'On-air' AND ((a.date_part||' '||a.time_part)::timestamp at time zone 'UTC' at time zone 'HKT')::date < b.maintenance_timestamp::date)
    ) a
    INNER JOIN aliases.string_id AS b
    ON trim(TRAILING '.log' FROM trim(a.node)) = b.string_id;    
    
    INSERT INTO data.logs (
      alias_id, 
      node_type, 
      timestamp, 
      log_type, 
      record)
    SELECT
      b.alias_id,
      'a' AS node_type,
      (a.date_part||' '||a.time_part)::timestamp at time zone 'UTC' at time zone 'HKT' AS timestamp,
      trim(a.type) AS log_type,
      trim(a.record) AS record
    FROM tmp.node_a_event AS a
    INNER JOIN aliases.string_id AS b
    ON trim(TRAILING '.log' FROM trim(a.node)) = b.string_id
    AND a.record not like '%A Non-Local MAU Has Been Chosen as the Active Client. The Active Client MAU LDN%'
    AND a.record not like '%Licensing%';
    
    INSERT INTO data.logs (
      alias_id, 
      node_type, 
      timestamp, 
      log_type, 
      flag, 
      record)
    SELECT
      b.alias_id,
      'b' AS node_type,
      (a.date_part||' '||a.time_part)::timestamp at time zone 'UTC' at time zone 'HKT' AS timestamp,
      trim(a.type) AS log_type,
      trim(a.flag) AS flag,
      trim(a.record) AS record
    FROM tmp.node_b_alarm AS a
    INNER JOIN aliases.string_id AS b
    ON trim(TRAILING '.log' FROM trim(a.node)) = b.string_id
    WHERE a.record not like '%Licensing%';
    
    INSERT INTO data.logs (
      alias_id, 
      node_type, 
      timestamp, 
      log_type, 
      record)
    SELECT
      b.alias_id,
      'b' AS node_type,
      (a.date_part||' '||a.time_part)::timestamp at time zone 'UTC' at time zone 'HKT' AS timestamp,
      trim(a.type) AS log_type,
      trim(a.record) AS record
    FROM tmp.node_b_event AS a
    INNER JOIN aliases.string_id AS b
    ON trim(TRAILING '.log' FROM trim(a.node)) = b.string_id
    AND a.record not like '%A Non-Local MAU Has Been Chosen as the Active Client. The Active Client MAU LDN%'
    AND a.record not like '%Licensing%';
    
    ANALYZE data.logs;

END;

$BODY$
  LANGUAGE 'plpgsql' VOLATILE;
ALTER FUNCTION data.logs() OWNER TO xsl;

---------------------------------------------------------------------------------------------------
-- data.node_b_to_node_a

CREATE OR REPLACE FUNCTION data.node_b_to_node_a()
RETURNS SETOF text AS
$BODY$

BEGIN

    INSERT INTO aliases.string_id (string_id) -- alias_id will be autogenerated
    SELECT a.string_id
    FROM (
      SELECT lower(trim(node_a)) AS string_id FROM tmp.node_b_to_node_a GROUP BY 1 UNION
      SELECT lower(trim(node_b)) AS string_id FROM tmp.node_b_to_node_a GROUP BY 1
    ) AS a
    LEFT JOIN aliases.string_id AS b
    ON a.string_id = b.string_id
    WHERE b.string_id IS NULL
    GROUP BY a.string_id;
    
    INSERT INTO data.node_b_to_node_a (
      alias_id_a,
      alias_id_b )
    SELECT
      a.alias_id AS alias_id_a,
      b.alias_id AS alias_id_b
    FROM tmp.node_b_to_node_a AS d
    INNER JOIN aliases.string_id AS a
    ON lower(trim(d.node_a)) = a.string_id
    INNER JOIN aliases.string_id AS b
    ON lower(trim(d.node_b)) = b.string_id
    LEFT JOIN data.node_b_to_node_a AS e
    ON a.alias_id = e.alias_id_a AND b.alias_id = e.alias_id_b
    WHERE e.alias_id_a IS NULL;

ANALYZE data.node_b_to_node_a;

END;

$BODY$
  LANGUAGE 'plpgsql' VOLATILE;
ALTER FUNCTION data.node_b_to_node_a() OWNER TO xsl;

---------------------------------------------------------------------------------------------------
-- data.node_a_alarm_severity

CREATE OR REPLACE FUNCTION data.node_a_alarm_severity()
RETURNS SETOF text AS
$BODY$

BEGIN

    INSERT INTO data.node_a_alarm_severity (
      flag,
      description )
    SELECT
      trim(a.flag) AS flag,
      trim(a.description) AS description
    FROM tmp.node_a_alarm_severity AS a
    LEFT JOIN data.node_a_alarm_severity AS b
    ON trim(a.flag) = b.flag
    WHERE b.flag IS NULL;
    
    ANALYZE data.node_a_alarm_severity;

END;

$BODY$
  LANGUAGE 'plpgsql' VOLATILE;
ALTER FUNCTION data.node_a_alarm_severity() OWNER TO xsl;

---------------------------------------------------------------------------------------------------


CREATE OR REPLACE FUNCTION data.parse_logs_aggregate_query(in_node_type text, in_log_type text, in_date_trunc text, in_date_shift interval, in_keyword_prefix text, in_string_operation text)
  RETURNS text AS
$BODY$

DECLARE
  query1 text;
  query2 text;
  string_operation text := (
    CASE
      WHEN char_length(in_string_operation) > 0 THEN in_string_operation -- Simple sanity check
      ELSE E'regexp_replace(btrim(regexp_replace(record, E''[A-z0-9\\\\s]*\\\\=[^\\\\s,]*'', '''', ''g''), '', ''), ''[0-9]+'', ''x'', ''g'')'
    END );

BEGIN

  string_operation := ''''||in_keyword_prefix||'''||('||string_operation||')';

  -- keyword_id will be autogenerated
  query1 := 
' INSERT INTO data.logs_aggregates_keywords (
    node_type,
    log_type,
    date_trunc,
    keyword_prefix,
    keyword )
  SELECT 
    d.node_type, 
    d.log_type, 
    d.date_trunc, 
    d.keyword_prefix, 
    d.keyword
  FROM (
    SELECT
      '''||in_node_type||''' AS node_type,
      '''||in_log_type||''' AS log_type,
      '''||in_date_trunc||''' AS date_trunc,
      '''||in_keyword_prefix||''' AS keyword_prefix,
      '||string_operation||' AS keyword
    FROM data.logs AS a
    WHERE a.node_type = '''||in_node_type||'''
    AND a.log_type = '''||in_log_type||'''
    GROUP BY keyword
  ) AS d
  LEFT JOIN data.logs_aggregates_keywords AS e
  ON d.node_type = e.node_type AND d.log_type = e.log_type AND d.date_trunc = e.date_trunc AND d.keyword = e.keyword
  WHERE e.keyword_id IS NULL
  ORDER BY d.node_type, d.log_type, d.date_trunc, d.keyword_prefix, d.keyword;';

  EXECUTE query1;

  query2 := 
' INSERT INTO data.logs_aggregates (
    alias_id,
    end_time,
    keyword_id,
    count )
  SELECT
    b.alias_id,
    b.start_time + ''1 '||in_date_trunc||'''::interval AS end_time,
    c.keyword_id,
    b.count
  FROM (
    SELECT
      a.alias_id,
      date_trunc('''||in_date_trunc||''', a.timestamp + '''||in_date_shift||'''::interval) - '''||in_date_shift||'''::interval AS start_time,
      '||string_operation||' AS keyword,
      count(*) AS count
    FROM data.logs AS a
    WHERE a.node_type = '''||in_node_type||''' 
    AND a.log_type = '''||in_log_type||'''
    GROUP BY a.alias_id, start_time, keyword
  ) AS b
  INNER JOIN data.logs_aggregates_keywords AS c
  ON b.keyword = c.keyword
  WHERE c.node_type = '''||in_node_type||''' 
  AND c.log_type = '''||in_log_type||'''
  AND c.date_trunc = '''||in_date_trunc||''';';

  EXECUTE query2;

  RETURN query1||'
--------------------
'||query2;

END;

$BODY$
  LANGUAGE plpgsql VOLATILE;
ALTER FUNCTION data.parse_logs_aggregate_query(text, text, text, interval, text, text) OWNER TO xsl;

--------------------------------------------------------------------------------------------------

-- Function: data.aggregate_logs()

-- DROP FUNCTION data.aggregate_logs();

CREATE OR REPLACE FUNCTION data.aggregate_logs()
  RETURNS SETOF text AS
$BODY$

BEGIN

  TRUNCATE data.logs_aggregates;
  
  DROP TABLE data.logs_aggregates_keywords;
  
  CREATE TABLE data.logs_aggregates_keywords (
    keyword_id       serial,
    node_type        character(1),
    log_type         varchar(4),
    date_trunc       text,
    keyword_prefix   text,
    keyword          text, 
    PRIMARY KEY (node_type, log_type, date_trunc, keyword))
  DISTRIBUTED BY (node_type, log_type, date_trunc, keyword);  
  
  ALTER TABLE data.logs_aggregates_keywords OWNER TO xsl;

  FOR i IN 0..6 LOOP
  
     RETURN NEXT (SELECT * FROM data.parse_logs_aggregate_query('a',   'AL', 'week', (i||' days 12 hours')::interval, 'a_al_week_flag_',   'flag'));
     RETURN NEXT (SELECT * FROM data.parse_logs_aggregate_query('a',   'EV', 'week', (i||' days 12 hours')::interval, 'a_ev_week_record_',     ''));
     RETURN NEXT (SELECT * FROM data.parse_logs_aggregate_query('a', 'LLOG', 'week', (i||' days 12 hours')::interval, 'a_llog_week_flag_', 'flag'));
     RETURN NEXT (SELECT * FROM data.parse_logs_aggregate_query('b',   'AL', 'week', (i||' days 12 hours')::interval, 'b_al_week_flag_',   'flag'));   
     RETURN NEXT (SELECT * FROM data.parse_logs_aggregate_query('b',   'EV', 'week', (i||' days 12 hours')::interval, 'b_ev_week_record_',  
     E'CASE 
         WHEN regexp_replace(regexp_replace(regexp_replace(regexp_replace(record, ''[0-9]+'', '' '', ''g''), E''(\\\\.|,)'', '''', ''g''), E''([^\\\\s]+=[^\\\\s]*)'', '''', ''g''), E''(\\\\s{2,}|^\\\\s*|\\\\s*$)'', '''', ''g'') ~ ''BoardRestart'' 
         THEN ''BoardRestart''
         WHEN regexp_replace(regexp_replace(regexp_replace(regexp_replace(record, ''[0-9]+'', '' '', ''g''), E''(\\\\.|,)'', '''', ''g''), E''([^\\\\s]+=[^\\\\s]*)'', '''', ''g''), E''(\\\\s{2,}|^\\\\s*|\\\\s*$)'', '''', ''g'') ~ ''^NssSynchronization'' 
         THEN ''NssSynchronization''
         ELSE regexp_replace(regexp_replace(regexp_replace(regexp_replace(record, ''[0-9]+'', '' '', ''g''), E''(\\\\.|,)'', '''', ''g''), E''([^\\\\s]+=[^\\\\s]*)'', '''', ''g''), E''(\\\\s{2,}|^\\\\s*|\\\\s*$)'', '''', ''g'') 
       END'));

  --RETURN NEXT (
  --SELECT * FROM data.parse_logs_aggregate_query('a',   'EV', 'week', (i||'days 12 hours')::interval, 'a_ev_week_record_',
  --'trim(regexp_replace(regexp_replace(regexp_replace(replace(record,
  --'' = '',''=''), 
  --E''\\\\s+.*\\\\s+'','','',''g''),
  --E''[\\\\w,.:]*$'', ''''),
  --E''([\\\\w]*)=([-\\\\w/]*)'', E''\\\\1'', ''g''))'));

  --RETURN NEXT (
  --SELECT * FROM data.parse_logs_aggregate_query('a',   'AL', 'week', (i||'days 12 hours')::interval, 'a_al_week_record_',
  --'trim(btrim(regexp_replace(regexp_replace(regexp_replace(regexp_replace(replace(record,
  --E''\\\\ = '',''=''),
  --E''(\\\\w*)=(\\\\w*)'', E''{\\\\1}'', ''g''),
  --E''}[-():|.,\\\\[\\\\]_#<>/$*"\\\\w\\\\s+]*{'', '','', ''g''),
  --E''^[-.\\\\w\\\\s+]*'', ''''),
  --E''[-()_|.#:,\\\\[\\\\]\\\\w\\\\s+]*$'', ''''),
  --''{}''))'));
   
  END LOOP;

  RETURN NEXT(SELECT * FROM data.parse_logs_aggregate_query('a',   'AL', 'day', '12 hours'::interval, 'a_al_day_flag_',   'flag'));
  RETURN NEXT(SELECT * FROM data.parse_logs_aggregate_query('a',   'EV', 'day', '12 hours'::interval, 'a_ev_day_record_',     ''));
  RETURN NEXT(SELECT * FROM data.parse_logs_aggregate_query('a', 'LLOG', 'day', '12 hours'::interval, 'a_llog_day_flag_', 'flag'));
  RETURN NEXT(SELECT * FROM data.parse_logs_aggregate_query('b',   'AL', 'day', '12 hours'::interval, 'b_al_day_flag_',   'flag'));
  RETURN NEXT(SELECT * FROM data.parse_logs_aggregate_query('b',   'EV', 'day', '12 hours'::interval, 'b_ev_day_record_',
  E'CASE 
      WHEN regexp_replace(regexp_replace(regexp_replace(regexp_replace(record, ''[0-9]+'', '' '', ''g''), E''(\\\\.|,)'', '''', ''g''), E''([^\\\\s]+=[^\\\\s]*)'', '''', ''g''), E''(\\\\s{2,}|^\\\\s*|\\\\s*$)'', '''', ''g'') ~ ''BoardRestart'' 
      THEN ''BoardRestart''
      WHEN regexp_replace(regexp_replace(regexp_replace(regexp_replace(record, ''[0-9]+'', '' '', ''g''), E''(\\\\.|,)'', '''', ''g''), E''([^\\\\s]+=[^\\\\s]*)'', '''', ''g''), E''(\\\\s{2,}|^\\\\s*|\\\\s*$)'', '''', ''g'') ~ ''^NssSynchronization'' 
      THEN ''NssSynchronization''
      ELSE regexp_replace(regexp_replace(regexp_replace(regexp_replace(record, ''[0-9]+'', '' '', ''g''), E''(\\\\.|,)'', '''', ''g''), E''([^\\\\s]+=[^\\\\s]*)'', '''', ''g''), E''(\\\\s{2,}|^\\\\s*|\\\\s*$)'', '''', ''g'') 
    END'));

  --RETURN NEXT (
  --SELECT * FROM data.parse_logs_aggregate_query('a',   'EV', 'day', ('12 hours')::interval, 'a_ev_day_record_',
  --'trim(regexp_replace(regexp_replace(regexp_replace(replace(record,
  --'' = '',''=''), 
  --E''\\\\s+.*\\\\s+'','','',''g''),
  --E''[\\\\w,.:]*$'', ''''),
  --E''([\\\\w]*)=([-\\\\w/]*)'', E''\\\\1'', ''g''))'));

  --RETURN NEXT (
  --SELECT * FROM data.parse_logs_aggregate_query('a',   'AL', 'day', ('12 hours')::interval, 'a_al_day_record_',
  --'trim(btrim(regexp_replace(regexp_replace(regexp_replace(regexp_replace(replace(record,
  --E''\\\\ = '',''=''),
  --E''(\\\\w*)=(\\\\w*)'', E''{\\\\1}'', ''g''),
  --E''}[-():|.,\\\\[\\\\]_#<>/$*"\\\\w\\\\s+]*{'', '','', ''g''),
  --E''^[-.\\\\w\\\\s+]*'', ''''),
  --E''[-()_|.#:,\\\\[\\\\]\\\\w\\\\s+]*$'', ''''),
  --''{}''))'));
         
  ANALYZE data.logs_aggregates;
  ANALYZE data.logs_aggregates_keywords;
 
END;

$BODY$
  LANGUAGE plpgsql VOLATILE;
ALTER FUNCTION data.aggregate_logs() OWNER TO xsl;
---------------------------------------------------------------------------------------------------------------------------------------------

-- Function: data.stack_to_matrix()

-- DROP FUNCTION data.stack_to_matrix();

CREATE OR REPLACE FUNCTION data.stack_to_matrix()
  RETURNS text AS
$BODY$

DECLARE
  text1 text := 'CREATE TABLE data.logs_aggregates_matrix (alias_id, end_time, ';
  text2 text := '';
  i integer;

BEGIN

  -- We shouldn't use DROP TABLE IF EXISTS structure in productized functions but OK here to cut some corners and save time
  DROP TABLE IF EXISTS data.logs_aggregates_matrix;
    
  FOR i IN SELECT DISTINCT keyword_id FROM data.logs_aggregates_keywords LOOP

    text1 := text1||'
    x'||i||', ';

    text2 := text2||'
    max(CASE WHEN keyword_id = '||i||' THEN count ELSE NULL END) AS x'||i||',';

  END LOOP;

  text1 := trim(TRAILING ', ' FROM text1)||')'||'
  AS SELECT alias_id, end_time, ';

  text2 := trim(TRAILING ', ' FROM text2)||' '||'
  FROM data.logs_aggregates GROUP BY alias_id, end_time;';

  raise notice '%: Start executing the SQL.', now();

  EXECUTE text1||text2;

  raise notice '%: Execution finished. Analyzing the target table.', now();

  ANALYZE data.logs_aggregates_matrix;

  RETURN text1||text2;

END;

$BODY$
  LANGUAGE plpgsql VOLATILE;
ALTER FUNCTION data.stack_to_matrix() OWNER TO xsl;




-----------------------------------------------------------------------------------------------------------------------------------------------------


-- Function: data.create_modelling_data_matrix()

-- DROP FUNCTION data.create_modelling_data_matrix();

CREATE OR REPLACE FUNCTION data.create_modelling_data_matrix()
  RETURNS text AS
$BODY$

DECLARE
  target_kw text := 'a_llog_day_flag_';
  varnames_1 text := (SELECT string_agg('c.x'||keyword_id||' AS x'||keyword_id||'_'||keyword_prefix, ', ' ORDER BY keyword_id) FROM data.logs_aggregates_keywords WHERE node_type = 'a');
  varnames_2 text := (SELECT string_agg('d.x'||keyword_id||'_'||keyword_prefix||'sum', ', ' ORDER BY keyword_id) FROM data.logs_aggregates_keywords WHERE node_type = 'b');
  aggregates_2 text := (SELECT string_agg('sum(v.x'||keyword_id||')::integer AS x'||keyword_id||'_'||keyword_prefix||'sum', ', ' ORDER BY keyword_id) FROM data.logs_aggregates_keywords WHERE node_type = 'b');
  query text;

BEGIN

  -- We shouldn't use DROP TABLE IF EXISTS structure in productized functions but OK here to cut some corners and save time
  DROP TABLE IF EXISTS data.modelling_data_matrix;
  
  -- We shouldn't use CREATE TABLE AS SELECT structure in productized functions but OK here to cut some corners and save time
  query := '-- Query: 
  CREATE TABLE data.modelling_data_matrix AS
  SELECT
    a.alias_id,
    a.source_period_end_time,
    CASE WHEN b.restart_count IS NULL THEN -1 WHEN b.restart_count < 1 THEN -1 ELSE 1 END AS target,
    EXTRACT(DOW FROM a.source_period_end_time) AS dow,
    EXTRACT(DAY FROM a.source_period_end_time) AS day,
    '||varnames_1||',
    '||varnames_2||'
  FROM (
    SELECT a1.alias_id, a2.source_period_end_time -- All combinations of RNCs and source period end dates
    FROM (SELECT DISTINCT alias_id FROM data.logs WHERE node_type = ''a'') AS a1
    CROSS JOIN (
      SELECT s.min_time + (generate_series(0, s.max_time::date - s.min_time::date)||'' days'')::interval AS source_period_end_time
      FROM (
        SELECT 
          min(s1.end_time) + ''7 days''::interval AS min_time, -- source period length added
          max(s1.end_time) - ''1 days''::interval AS max_time  -- target period length subtracted
        FROM data.logs_aggregates AS s1
        INNER JOIN data.logs_aggregates_keywords AS s2
        ON s1.keyword_id = s2.keyword_id
        WHERE s2.keyword_prefix = '''||target_kw||'''
      ) AS s
    ) AS a2
  ) AS a
  LEFT JOIN (
    SELECT b1.alias_id, b1.end_time, sum(b1.count) AS restart_count -- RNC restarts (target variable)
    FROM data.logs_aggregates AS b1
    INNER JOIN data.logs_aggregates_keywords AS b2
    ON b1.keyword_id = b2.keyword_id
    WHERE b2.keyword_prefix = '''||target_kw||'''
    GROUP BY b1.alias_id, b1.end_time
  ) AS b
  ON a.alias_id = b.alias_id 
  AND a.source_period_end_time + ''1 day''::interval = b.end_time
  LEFT JOIN data.logs_aggregates_matrix AS c -- Predictors
  ON a.alias_id = c.alias_id
  AND a.source_period_end_time = c.end_time
  LEFT JOIN ( -- Preditors from Node B data
    SELECT
      u.alias_id_a,
      v.end_time AS b_end_time,
      '||aggregates_2||'
    FROM data.node_b_to_node_a AS u
    INNER JOIN data.logs_aggregates_matrix AS v
    ON u.alias_id_b = v.alias_id
    GROUP BY u.alias_id_a, v.end_time
  ) AS d 
  ON a.alias_id = d.alias_id_a
  AND a.source_period_end_time = d.b_end_time';

  EXECUTE query;

  ANALYZE data.modelling_data_matrix;

  RETURN query;

END;

$BODY$
  LANGUAGE plpgsql VOLATILE;
ALTER FUNCTION data.create_modelling_data_matrix() OWNER TO xsl;


-----------------------------------------------------------------------------------------------


--ADDING WEATHER DATA

-- Function: data.weather()

-- DROP FUNCTION data.weather();

CREATE OR REPLACE FUNCTION data.weather()
  RETURNS void AS
$BODY$
BEGIN

DROP TABLE IF EXISTS data.weather;


CREATE TABLE data.weather AS (

SELECT
	( year ||'-'|| month ||'-'||day  )::timestamp without time zone AS timestamp,
	pressure::double precision as pressure,
	temp_max::double precision as temp_max,
	temp_mean::double precision as temp_mean,
	temp_min::double precision as temp_min,
	dew_point_temp::double precision as dew_point_temp,
	humidity::double precision as humidity,
	cloud_amount::double precision as cloud_amount,
	CASE WHEN rainfall =  '-' OR rainfall='Trace' THEN 0 ELSE rainfall::double precision END AS rainfall,
	CASE WHEN rainmall_mod =  '-' OR rainmall_mod='Trace' THEN 0 ELSE rainmall_mod::double precision END AS rainmall_mod
FROM tmp.weather );


END;

$BODY$
  LANGUAGE plpgsql VOLATILE;
ALTER FUNCTION data.weather() OWNER TO xsl;


-------------------------------------------------------------------------------

--combining with modelling_data_matrix

CREATE OR REPLACE FUNCTION data.create_modelling_data_matrix_weather()
  RETURNS void AS
$BODY$

BEGIN

DROP TABLE IF EXISTS data.modelling_data_matrix_weather;

	CREATE TABLE data.modelling_data_matrix_weather AS
		(
		SELECT a.*,
			b.*
		FROM data.modelling_data_matrix a
		LEFT JOIN data.weather b
		ON a.source_period_end_time= timestamp - '1 day 12 hours'::interval
		);

END;

$BODY$
  LANGUAGE plpgsql VOLATILE;
ALTER FUNCTION data.create_modelling_data_matrix_weather() OWNER TO xsl;


--------------------------------------------------------------------------------

---insights on the restarts only




CREATE OR REPLACE FUNCTION data.restarts()
  RETURNS SETOF text AS
$BODY$

BEGIN
INSERT INTO data.restarts (board,subrack,rnc,time,record)
SELECT 
 a.board,
 a.subrack, 
 b.string_id,
 a.timestamp,
 a.record
FROM (
	SELECT 
	alias_id,
	timestamp,
	flag,
	record,
	substr(flag,1,2) as subrack, 
	substr(flag,3,5) AS board
	FROM  data.logs 
	WHERE log_type='LLOG'
	) AS a
LEFT JOIN aliases.string_id AS b
ON a.alias_id = b.alias_id;

END;

$BODY$
  LANGUAGE plpgsql VOLATILE;
ALTER FUNCTION data.restarts() OWNER TO xsl;


